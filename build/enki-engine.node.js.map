{"version":3,"sources":["webpack://EnkiEngine/webpack/universalModuleDefinition","webpack://EnkiEngine/webpack/bootstrap","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/bytesToUuid.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/index.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/md5.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/rng.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/sha1.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v1.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v3.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v35.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v4.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v5.js","webpack://EnkiEngine/./src/componentManager.js","webpack://EnkiEngine/./src/entityManager.js","webpack://EnkiEngine/./src/index.js","webpack://EnkiEngine/./src/storage/index.js","webpack://EnkiEngine/./src/storage/memoryStorage.js","webpack://EnkiEngine/./src/systemManager.js","webpack://EnkiEngine/./src/templateManager.js","webpack://EnkiEngine/./src/utils/errors.js","webpack://EnkiEngine/./src/utils/validate.js","webpack://EnkiEngine/external \"crypto\""],"names":[],"mappings":"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;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4CAAQ;AACzB,wBAAwB,EAAE,MAAM,kBAAkB,yBAAyB,qBAAqB;AAChG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,mCAAmC,YAAY;AACzE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,8BAA8B,cAAc,sBAAsB,SAAS;AAC3E;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA,SAAS;AACT,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChKA;AAAA;AAAA;AAAkC;;AAE3B;AACP;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA,6BAA6B,+CAAM;AACnC;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC,iBAAiB;AACjB;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD;AACM;AACN;AACC;AACP;;AAE3C;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,IAAI;AACf,cAAc,gBAAgB,2CAA2C,qBAAqB,oEAAoE,kBAAkB;AACpL;AACA;AACA,iBAAiB,oFAAoF,KAAK;;AAE1G;AACA,iDAAiD,YAAY;;AAE7D;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,yDAAO;AACzB;;AAEA,sBAAsB,uEAAa;;AAEnC,yBAAyB,6EAAgB;;AAEzC,sBAAsB,uEAAa;;AAEnC,wBAAwB,wEAAe;;AAEvC;AACA;AACA;AACA,iBAAiB,iDAAiD;AAClE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,qEAAM,EAAC;AACf,iBAAiB,yDAAO,C;;;;;;;;;;;;AC5E/B;AAAA;AAAA;AAAgD;;AAEzC;AACP,EAAE,2EAAa;AACf;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,WAAW,IAAI,gBAAgB,IAAI,qBAAqB,IAAI,GAAG;AAC3E,cAAc;AACd;AACA;AACO,0CAA0C;AACjD;AACA,iDAAiD;AACjD,yDAAyD;AACzD,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,6BAA6B,SAAS;AACtC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB,IAAI;AACrB;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA,8BAA8B,cAAc,aAAa,SAAS;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA,iCAAiC,cAAc,aAAa,SAAS;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChKA;AAAA;AAAA;AAAmD;;AAE5C;;AAEP;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,+DAAO;AACpB,2BAA2B,YAAY;AACvC;AACA;;AAEA,aAAa,+DAAO;AACpB,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,iBAAiB,IAAI,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C,iDAAiD,+DAA+D;AAChH;AACA,SAAS;AACT,2BAA2B,YAAY;AACvC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA,YAAY,gEAAQ;AACpB;AACA;AACA,SAAS;AACT,0BAA0B,UAAU;AACpC;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AChIA;AAAA;AAAA;AAAA;AAA+C;AACU;;AAElD;AACP;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,eAAe,IAAI;AACnB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA,aAAa,gEAAQ;AACrB,sBAAsB,6DAAe;AACrC;;AAEA;AACA;AACA,sBAAsB,6DAAe;AACrC;;AAEA,aAAa,+DAAO;AACpB,sBAAsB,6DAAe;AACrC;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,0BAA0B,6DAAe,cAAc,UAAU;AACjE;AACA;;AAEA,uCAAuC,6DAAK;AAC5C,sBAAsB,6DAAe;AACrC;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,uDAAuD,UAAU;AACjE;;AAEA;AACA,kEAAkE,UAAU;AAC5E;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAe;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7LA;AAAA;AAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAEjC;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAe,SAAS,KAAK;AACnD;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;;AAGA,C;;;;;;;;;;;AClHA,mC","file":"enki-engine.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EnkiEngine\"] = factory();\n\telse\n\t\troot[\"EnkiEngine\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction bytesToUuid(buf, offset_) {\n  const offset = offset_ || 0; // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n\n  return (byteToHex[buf[offset + 0]] + byteToHex[buf[offset + 1]] + byteToHex[buf[offset + 2]] + byteToHex[buf[offset + 3]] + '-' + byteToHex[buf[offset + 4]] + byteToHex[buf[offset + 5]] + '-' + byteToHex[buf[offset + 6]] + byteToHex[buf[offset + 7]] + '-' + byteToHex[buf[offset + 8]] + byteToHex[buf[offset + 9]] + '-' + byteToHex[buf[offset + 10]] + byteToHex[buf[offset + 11]] + byteToHex[buf[offset + 12]] + byteToHex[buf[offset + 13]] + byteToHex[buf[offset + 14]] + byteToHex[buf[offset + 15]]).toLowerCase();\n}\n\nexport default bytesToUuid;","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';","import crypto from 'crypto';\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('md5').update(bytes).digest();\n}\n\nexport default md5;","import crypto from 'crypto';\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  return crypto.randomFillSync(rnds8);\n}","import crypto from 'crypto';\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('sha1').update(bytes).digest();\n}\n\nexport default sha1;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || bytesToUuid(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;","import bytesToUuid from './bytesToUuid.js';\n\nfunction uuidToBytes(uuid) {\n  // Note: We assume we're being passed a valid uuid string\n  const bytes = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {\n    bytes.push(parseInt(hex, 16));\n  });\n  return bytes;\n}\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = uuidToBytes(namespace);\n    }\n\n    if (!Array.isArray(value)) {\n      throw TypeError('value must be an array of bytes');\n    }\n\n    if (!Array.isArray(namespace) || namespace.length !== 16) {\n      throw TypeError('namespace must be uuid string or an Array of 16 byte values');\n    } // Per 4.3\n\n\n    const bytes = hashfunc(namespace.concat(value));\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return bytesToUuid(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return bytesToUuid(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import * as Validate from './utils/validate';\n\nexport const ComponentManager = (storage, verbose) => {\n\n    const _storage = storage;\n    const _registeredComponents = new Map();\n\n    const _log = (...$msg) => {\n        if (verbose) {\n            console.log('Component Manager: ', ...$msg);\n        }\n    };\n\n    const _validate = (ComponentId, componentValue) => {\n        //check if component is registered\n        const c = _registeredComponents.get(ComponentId);\n        if (typeof c === 'undefined') {\n            _log(`Component ${ComponentId} is not registered`);\n            return false;\n        }\n\n        //check if values are correct\n        for (let [k, v] of Object.entries(c)) {\n            const validateFunctionName = 'is' + v['type'].charAt(0).toUpperCase() + v['type'].slice(1);\n            //if value is not passed and we have a default or value is optional then we are good\n            if (typeof componentValue[k] === 'undefined' && (\n                (typeof (v.optional) !== 'undefined' && v.optional === true) ||\n                typeof (v.default) !== 'undefined')\n            ) {\n                continue;\n            }\n            // 'any' type of data is not validated.\n            if (v.type == 'any') {\n                continue;\n            }\n            //we have a value so we test\n            let args = [];\n            if (v.type == 'enum') {\n                args.push(v.allowed);\n            }\n            if (v.type == 'array') {\n                args.push(v.childType);\n            }\n            if (!Validate[validateFunctionName](componentValue[k], ...args)) {\n                _log(`${k} => ${componentValue[k]} failed the validation ${validateFunctionName}`);\n                return false;\n            }\n        }\n\n        //check if extra non existent property were passed to component\n        const defaultSchema = Object.keys(c);\n        for (const k of Object.keys(componentValue)) {\n            if (!defaultSchema.includes(k)) {\n                _log(`${k} is not a valid property for the ${ComponentId} Component.`);\n                return false;\n            }\n        }\n\n        return true;\n    };\n\n    /**\n     * Add a Component to an existing entity\n     * @param {any} entityId - Entity Id\n     * @param {string} ComponentId - Component type to add\n     * @param {object} value - Object following the data structure of component to pass initial values to component\n     * @returns {boolean} True if succesfull else false\n     */\n    const add = (entityId, ComponentName, value = {}) => {\n        if (_validate(ComponentName, value)) {\n            const c = _registeredComponents.get(ComponentName);\n            const defaultValues = Object.fromEntries(Object.entries(c).map(([k, v]) => {\n                return [k, v.default];\n            }));\n            _storage.addEntityComponent(entityId, ComponentName, Object.assign(defaultValues, value));\n            return true;\n        } else {\n            _log(`Component ${ComponentName} could not added to ${entityId} due to fail validation.`);\n            return false;\n        }\n    };\n\n    /**\n     * Remove a component from an existing Entity\n     * @param {any} entityId - Entity Id\n     * @param {string} ComponentName - Component to remove\n     * @returns {boolean} - True if successfull else false\n     */\n    const remove = (entityId, ComponentName) => {\n        return _storage.removeEntityComponent(entityId, ComponentName);\n    };\n\n    /**\n     * Register a new component type\n     * @param {object} componentSchema\n     * @returns {boolean} - True if successfull, else false\n     */\n    const register = (componentSchema) => {\n        if (!componentSchema.hasOwnProperty('name')) {\n            return false;\n        }\n        _log(`Registering ${componentSchema.name} Component`)\n        const data = componentSchema.data || {};\n        _registeredComponents.set(componentSchema.name, data);\n        return true;\n    };\n\n    const list = () => {\n        return new Map(_registeredComponents)\n    }\n\n    const isRegistered = (name) => {\n        return _registeredComponents.has(name);\n    }\n\n    const dump = () => {\n        const res = []\n        _registeredComponents.forEach((data, name) => {\n            if (Object.keys(data).length === 0 && data.constructor === Object) {\n                res.push({name})\n            } else {\n                res.push({\n                    name: name,\n                    data: data\n                })\n            }\n\n        })\n        return {components: res};\n    }\n\n    const load = (data) => {\n        if (!data.hasOwnProperty('components')) {\n            return false\n        }\n        //register all components\n        for (let c of data['components']) {\n            register(c)\n        }\n        \n        // add all components to dumped entities\n        if (data.hasOwnProperty('entities')) {\n            for (let e of data['entities']) {\n                for (let c of e['components']) {\n                    add(e['id'], c['name'], c['data'])\n                }\n            }\n        }\n        return true\n    }\n\n    return {\n        add,\n        remove,\n        register,\n        list,\n        isRegistered,\n        dump,\n        load\n    };\n};\n","import {v4 as uuidv4} from 'uuid';\n\nexport const EntityManager = (storage) => {\n    const _storage = storage;\n\n    /**\n     * Add a new entity\n     * @param {string} [id] - Entity Id\n     * @returns {string} - Entity Id\n     */\n    const add = (id) => {\n        const entity = id || uuidv4();\n        _storage.addEntity(entity);\n        return entity;\n    };\n\n    /**\n     * Remove an entity\n     * @param {*} entity - Entity Id to remove\n     * @returns {boolean} - True if successful, else false\n     */\n    const remove = (entity) => {\n        return _storage.removeEntity(entity);\n    };\n\n    /**\n     * Retrieve an entity and its components\n     * @param {*} id - Entity Id\n     * @returns {{id:string, components: Map}} - Entity Object with id and components. Undefined if it does not exists\n     */\n    const get = (id) => {\n        const eid = _storage.getEntity(id);\n        if (typeof eid == 'undefined') {\n            return;\n        }\n        const components = _storage.getEntityComponents(eid)\n        return {\n            id: eid,\n            components: components\n        };\n    };\n\n    /**\n     * Retrieve all entities stored\n     * @returns {Iterator} - Iterator that list all entities\n     */\n    const list = () => {\n        return _storage.getEntities().values();\n    };\n\n    const dump = () => {\n        //dump entities\n        const data = {\n            entities: []\n        };\n        const entities = list();\n        for (let e of entities) {\n            const entity = get(e)\n            const c = []\n            entity['components'].forEach((data, name) => {\n                if (Object.keys(data).length === 0 && data.constructor === Object) {\n                    c.push({name})\n                } else {\n                    c.push({\n                        name: name,\n                        data: data\n                    })\n                }\n\n            })\n            const en = {\n                id: e,\n                components: c\n            }\n            data['entities'].push(en);\n        }\n        return data;\n    };\n\n    const load = (data) => {\n        if (!data.hasOwnProperty('entities')) {\n            return false\n        }\n        for (let e of data['entities']) {\n            add(e['id'])\n        }\n        return true;\n    }\n\n    return {\n        add,\n        get,\n        list,\n        remove,\n        dump,\n        load\n    };\n};\n","import {EntityManager} from './entityManager.js';\nimport {ComponentManager} from './componentManager.js';\nimport {SystemManager} from './systemManager.js';\nimport {TemplateManager} from './templateManager';\nimport {Storage} from './storage/index.js';\n\n/**\n * Create an Enki Engine instance\n * @param {string} storageType - The type of storage to use, either 'MemoryStorage' or 'custom'\n * @param {string} mode - debug or production.\n * @param {func} storageInstance - a Storage instance, only used if storageType is set to 'custom'\n * @param {any} rest - unused at the moment\n * @returns {{EntityManager: {add: (function(*): string), remove: remove}, ComponentManager: {add: add, remove: (function(*=, *=): boolean|*), register: register}, SystemManager: {execute: execute, register: register}}}\n * @constructor\n */\nconst Engine = ({storageType = 'MemoryStorage', mode = 'production', storageInstance = null, ...rest} = {}) => {\n\n    //get storage\n    console.log(`Starting Enki ECS Engine with ${storageType}`)\n\n    const verbose = mode == 'debug' ? true : false;\n    let storage = null;\n    if (storageType == 'custom') {\n        storage = storageInstance(verbose);\n    } else {\n        storage = Storage[storageType](verbose);\n    }\n\n    const entityMgr = EntityManager(storage, verbose);\n\n    const componentMgr = ComponentManager(storage, verbose);\n\n    const systemMgr = SystemManager(storage, verbose);\n\n    const templateMgr = TemplateManager(entityMgr, componentMgr, verbose);\n\n    /**\n     * Dump the full state in an Object\n     * than can be serialised\n     * @return {{templates:Array,entities:Array,components:Array}} - dump of state\n     */\n    const dump = () => {\n        let dump = {}\n\n        dump = Object.assign(dump, templateMgr.dump());\n        dump = Object.assign(dump, entityMgr.dump());\n        dump = Object.assign(dump, componentMgr.dump());\n\n        return dump;\n    }\n\n    /**\n     * Load a given state\n     * @param data\n     * @return {boolean} - True if successful\n     */\n    const load = (data) => {\n        return templateMgr.load(data) &&\n                entityMgr.load(data) &&\n                componentMgr.load(data);\n    }\n\n\n    return {\n        EntityManager: entityMgr,\n        SystemManager: systemMgr,\n        ComponentManager: componentMgr,\n        TemplateManager: templateMgr,\n        Storage: storage,\n        dump,\n        load,\n    }\n\n}\n\nexport default Engine;\nexport const _storage = Storage;","import { MemoryStorage } from './memoryStorage';\n\nexport const Storage =  {\n  MemoryStorage\n}\n","/**\n *\n * @param {boolean} verbose - If True will send log to console\n * @param {{Entities: {Set}, ComponentMap:{Map}, EntityComponents: {Map} }} state - Object containing 3 property that must react like Map or Set. Will be used to store the state\n * @returns {{addEntity: (function(*): Set<any>), removeEntityComponent: removeEntityComponent, getEntityComponents: (function(*): any), getEntities: (function(): Set<*>), addEntityComponent: addEntityComponent, getEntity: (function(*=): *), removeEntity: (function(*=): boolean), getEntityByComponents: (function(Array): *)}}\n * @constructor\n */\nexport const MemoryStorage = (verbose, state = {}) => {\n    const _verbose = verbose;\n    const Entities = state.Entities || new Set(); //list of entities created\n    const ComponentMap = state.ComponentMap || new Map(); //a map for quickly retrieve entity that have a given component (ComponentId => [entity1, entity2...])\n    const EntityComponents = state.EntityComponents || new Map(); // a 3D map with primary key being entity ID with a map of all components\n\n    const _log = (...$msg) => {\n        if (verbose) {\n            console.log('Memory Store: ', ...$msg)\n        }\n    }\n\n    /**\n     * Add an Entity to storage\n     * @param {any} entityId - Any value that is unique\n     * @returns {Set<any>}\n     */\n    const addEntity = (entityId) => {\n        EntityComponents.set(entityId, new Map())\n        _log(`Saving Entity ${entityId}`)\n        return Entities.add(entityId)\n    }\n\n    /**\n     * Remove an entity from storage\n     * This delete all its components as well\n     * @param entityId\n     * @returns {boolean}\n     */\n    const removeEntity = (entityId) => {\n        _log(`Removing Entity ${entityId}`)\n        const componentsName = EntityComponents.get(entityId)\n        componentsName.forEach((v,k) => {\n            ComponentMap.get(k).delete(entityId)\n        })\n        EntityComponents.delete(entityId)\n        return Entities.delete(entityId)\n    }\n\n    /**\n     * Return EntityId or undefined if the entity does not exists\n     * @param entityId\n     * @returns {entityId}\n     */\n    const getEntity = (entityId) => {\n        _log(`Get Entity ${entityId}`)\n        const e = Entities.has(entityId) ? entityId : undefined;\n        _log(`Found Entity ${entityId}`)\n        return e\n    }\n\n    /**\n     * Return a Set containing all entities\n     * @returns {Set<any>}\n     */\n    const getEntities = () => {\n        //returning a new set so users can not override the Entities Set by inadvertence\n        return new Set(Entities);\n    }\n\n    /**\n     * Get all components attached to an entity\n     * @param {any} entityId - EntityId to retrieve components from\n     * @returns {Set} - Set of components\n     */\n    const getEntityComponents = (entityId) => {\n        _log(`Get Entity Components for ${entityId}`)\n        return EntityComponents.has(entityId) ? EntityComponents.get(entityId) : new Map();\n    }\n\n    /**\n     * List all entities that have the component attached\n     * @param {array} components - array of components name\n     * @returns {Set} - List of entities\n     */\n    const getEntityByComponents = (components) => {\n        _log(`Get List of Entities by Components for `, components)\n        if (!Array.isArray(components)) {\n            throw Error('Components must be an array');\n        }\n        const e = components.reduce((acc, val) => {\n            if (acc.size == 0) {\n                return ComponentMap.get(val) || new Set();\n            }\n\n            return new Set([...acc].filter(i => {\n                const c = ComponentMap.get(val)\n                if(typeof c === 'undefined') {\n                    return false\n                }\n                return c.has(i)\n            }))\n        }, new Set());\n        _log(`Found Entities`, e)\n        return e;\n    }\n\n    /**\n     * Add a component to an entity\n     * @param {any} entityId - EntityId\n     * @param {string} componentName - Name of Component to add to entity\n     * @param {object} component - Component value for initialisation\n     */\n    const addEntityComponent = (entityId, componentName, component) => {\n        _log(`Add Component ${componentName} to Entity ${entityId}`)\n        if (!ComponentMap.has(componentName)) {\n            ComponentMap.set(componentName, new Set([entityId]));\n            EntityComponents.get(entityId).set(componentName, component);\n        } else {\n            ComponentMap.get(componentName).add(entityId);\n            EntityComponents.get(entityId).set(componentName, component);\n        }\n    }\n\n    /**\n     * Remove Component from an entity\n     * @param {any }entityId - EntityId to remove component from\n     * @param {string} componentName - Component Name\n     * @returns {boolean} - True if successfull\n     */\n    const removeEntityComponent = (entityId, componentName) => {\n        _log(`Remove Component ${componentName} to Entity ${entityId}`)\n        if (!ComponentMap.has(componentName)) {\n            return false;\n        } else {\n            return EntityComponents.get(entityId).delete(componentName) &&\n                ComponentMap.get(componentName).delete(entityId);\n        }\n    }\n\n    /**\n     * Return an object containing the current state\n     * @returns {{ComponentMap: Map<any, any>, EntityComponents: Map<any, any>, Entities: Set<any>}}\n     */\n    const getState = () => {\n        return {\n            Entities,\n            ComponentMap,\n            EntityComponents\n        }\n    }\n\n    return {\n        addEntity,\n        removeEntity,\n        getEntity,\n        getEntities,\n        addEntityComponent,\n        removeEntityComponent,\n        getEntityByComponents,\n        getEntityComponents,\n        getState\n    }\n}\n","import {isArray, isString} from './utils/validate';\n\nexport const SystemManager = (storage, verbose) => {\n\n    const _storage = storage;\n    const _registeredSystems = new Map();\n    const _registerEvents = new Set();\n\n\n    const _log = (...$msg) => {\n        if (verbose) {\n            console.log('System Manager: ', ...$msg)\n        }\n    }\n\n    const _query = (q) => {\n        return _storage.getEntityByComponents(q);\n    }\n\n    const _validate = (system) => {\n        //check that system is a function with the correct prototype\n        if (typeof (system) !== 'function' || !system.hasOwnProperty('query')) {\n            _log('Trying to register a system that is either not a function or does not have a name and query defined');\n            return false;\n        }\n\n        if (!isArray(system.query, 'string')) {\n            _log(`System ${system.name} does not have a correct query. A query must be an array of string.`)\n            return false;\n        }\n\n        if (!isArray(system.events, 'string')) {\n            _log(`System ${system.name} does not have a correct events trigger setup. Systems must have an events property that is an empty array or an array of Events name.`)\n            return false;\n        }\n\n        const res = system()\n        if (!res.hasOwnProperty('execute') || typeof (res.execute) !== 'function') {\n            _log(`System ${system.name} does not have an execute function`)\n            return false\n        }\n\n        if (!res.hasOwnProperty('events') || typeof (res.events) !== 'function') {\n            _log(`System ${system.name} does not have an events function`)\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Execute all registered systems\n     * @returns {Map{Array}} - Return values from each system\n     */\n    const execute = () => {\n        // loop through all systems\n        const returnValues = new Map();\n        for (let [name, system] of _registeredSystems) {\n            const entities = _query(system.query);\n            returnValues.set(name, new Map())\n            entities.forEach((e) => {\n                returnValues.get(name).set(e, system.instance.execute(_storage.getEntityComponents(e)))\n            })\n        }\n        return returnValues;\n    }\n\n    /**\n     * Register a new system\n     * @param {function} system - A system to be registered\n     * @returns {boolean} - True if successful else false\n     */\n    const register = (system) => {\n        if (_validate(system)) {\n            _log(`Registering ${system.name} System`)\n            _registeredSystems.set(system.name, {instance: system(), query: system.query, events: system.events});\n            return true;\n        } else {\n            _log(`System ${system.name} failed validation and was not registered.`);\n            return false;\n        }\n    }\n\n    /**\n     * Register Event\n     * @param {string} eventName - Event Name\n     * @returns {boolean} - True if registered\n     */\n    const registerEvent = (eventName) => {\n        if (isString(eventName)) {\n            _registerEvents.add(eventName);\n            return true;\n        } else {\n            _log(`Event ${eventName} failed validation and was not registered.`);\n            return false;\n        }\n    }\n\n    const triggerEvent = (eventName, eventData, filter) => {\n        if (!_registerEvents.has(eventName)) {\n            _log(`Event ${eventName} is not registered.`);\n            return false;\n        }\n\n        // loop through all systems\n        const returnValues = new Map();\n        for (let [name, system] of _registeredSystems) {\n            if (system.events.includes(eventName)) {\n                const entities = _query(system.query);\n                returnValues.set(name, new Map())\n                entities.forEach((e) => {\n                    if (!filter || filter.includes(e)) {\n                        returnValues.get(name).set(e, system.instance.events(_storage.getEntityComponents(e), eventName, eventData))\n                    }\n                })\n            }\n        }\n        return returnValues;\n    }\n\n    return {\n        execute,\n        register,\n        registerEvent,\n        triggerEvent\n    }\n\n}\n","import {ValidationError} from './utils/errors';\nimport {isString, isArray, isMap} from './utils/validate'\n\nexport const TemplateManager = (entityMgr, componentMgr, verbose) => {\n    const _registeredTemplates = new Map()\n\n    const _log = (...$msg) => {\n        if (verbose) {\n            console.log('Template Manager: ', ...$msg);\n        }\n    };\n\n\n    /**\n     * Register a new Template for use\n     *\n     * @param {string} name - Name of the template, must be unique\n     * @param {Array} components - Array of Components used by this templates. Cannot be empty.\n     * @param {Map} defaultValues - Map of default Values for each components in `components` param. Key must be a component name.\n     * @param {boolean} registerComponents - If true, will register components if they are not already registered. if false, will fail registration of template if a component is not registered\n     * @returns {Boolean} - True if registered\n     *\n     * @throws ValidationError - Error if the templates is invalid\n     */\n    const register = (name, components, defaultValues = null, registerComponents = true) => {\n        _log('Registering template')\n\n        if (!isString(name)) {\n            throw new ValidationError('Invalid name for template');\n        }\n\n        // check iof template already exists\n        if (_registeredTemplates.has(name)) {\n            throw new ValidationError('A template with this name already exists.');\n        }\n\n        if (!isArray(components, 'components') || components.length == 0) {\n            throw new ValidationError('Invalid components list');\n        }\n\n        // check if all components are registered, if not registered\n        for(let c of components) {\n            if(!componentMgr.isRegistered(c['name']) && registerComponents) {\n                componentMgr.register(c)\n            } else if (!componentMgr.isRegistered(c['name']) && !registerComponents) {\n                throw new ValidationError(`Component ${c['name']} is not registered.`);\n            }\n        }\n\n        if (defaultValues !== null && !isMap(defaultValues)) {\n            throw new ValidationError('defaultValues must be a Map.');\n        }\n\n        _log('Template validation successful')\n\n        _registeredTemplates.set(name, {\n            name,\n            components,\n            defaultValues: defaultValues || new Map()\n        })\n\n\n        return true;\n    }\n\n    /**\n     *  Create an entity based on the given template\n     * @param {string} templateName - Name of the template to use\n     * @param {Map} values - Map of component values\n     * @param {string} [entityId] - Optional Entity Id to use during creation\n     * @returns {string} - Id of the entity added\n     *\n     * @throws ValidationError|Error\n     */\n    const create = (templateName, values, entityId) => {\n        if (!_registeredTemplates.has(templateName)) {\n            throw new ValidationError('Template does not exist');\n        }\n\n        const template = _registeredTemplates.get(templateName);\n\n\n        const id = entityMgr.add(entityId)\n        for (let c of template['components']) {\n            try {\n                // prepare values for component\n                let v = {}\n                if(typeof values !== 'undefined') {\n                    v = values.get(c['name']);\n                }\n                const d = template['defaultValues'].get(c['name']) || {};\n                const data = Object.assign(d, v)\n\n                //add component to entity\n                componentMgr.add(id, c['name'], data)\n            } catch (err) {\n                //we need to delete the entity and all associated components\n                entityMgr.remove(id)\n                _log(`TemplateManager: Failed to add ${c['name']} component to entity.`)\n                _log(err.message)\n\n                //bubble up error\n                throw new Error(`TemplateManager: Failed to add ${c['name']} component to entity during creation.`)\n            }\n\n        }\n\n\n        return id;\n    }\n\n    /**\n     * Return a Map containing all registered templates\n     * @returns {Map<any, any>}\n     */\n    const list = () => {\n        return new Map(_registeredTemplates)\n    }\n\n    /**\n     * Remove a template.\n     * Removing a template does not remove existing enitties created with this template.\n     *\n     * @param {string} templateName - Name of the template to remove\n     * @returns {boolean} - True if template was removed\n     *\n     * @throws ValidationError\n     */\n    const remove = (templateName) => {\n        if (!_registeredTemplates.has(templateName)) {\n            throw new ValidationError('Template does not exist');\n        }\n        return _registeredTemplates.delete(templateName);\n    }\n\n    /**\n     * Load several templates and entities in one go from an object\n     *\n     * @param {object} schema - Object\n     */\n    const load = (data) => {\n        try {\n            if(data.hasOwnProperty('templates')) {\n                // register all templates\n                _log('Loading templates')\n                for( let t of data['templates']) {\n                    register(t['name'], t['components'], new Map(Object.entries(t['defaultValues'])))\n                }\n            } else {\n                _log('Your object must contains a `templates` property');\n                return false\n            }\n        } catch(err) {\n            _log(err);\n            throw new Error('Not able to load templates because of malformed data.');\n        }\n        return true\n    }\n\n    /**\n     * Dump all templates and template entities into an object\n     */\n    const dump = () => {\n        const data = {\n            templates: [],\n        }\n\n        // dump templates\n        _registeredTemplates.forEach((t) => {\n\n            data['templates'].push({\n                name: t['name'],\n                components: t['components'],\n                defaultValues: Object.fromEntries(t['defaultValues'])\n            });\n        })\n\n        return data;\n\n    }\n\n    return {\n        list,\n        register,\n        create,\n        remove,\n        dump,\n        load\n    };\n};\n","export class ValidationError extends Error {\n    constructor(message) {\n        super(message);\n\n        this.name = 'ValidationError';\n    }\n}\n","import {ValidationError} from './errors'\n\nexport const isNumber = (value) => {\n    return !isNaN(value)\n}\n\nexport const isAny = (value) => {\n    if (typeof (value) !== 'undefined') {\n        return true;\n    }\n    return false;\n}\n\nexport const isString = (value) => {\n    if (typeof value === 'string' || value instanceof String) {\n        return true;\n    }\n    return false;\n}\n\nexport const isEnum = (value, allowed) => {\n    return allowed.includes(value)\n}\n\nexport const isArray = (value, type) => {\n    //check if array\n    if (!Array.isArray(value)) {\n        return false\n    }\n\n    //not checking types\n    if(typeof type == 'undefined') {\n        return true\n    }\n\n    //check type\n    let res = false;\n    switch (type) {\n        case 'string':\n            res = value.reduce((acc, cur) => {\n                return acc && isString(cur)\n            }, true)\n            break;\n        case 'number':\n            res = value.reduce((acc, cur) => {\n                return acc && isNumber(cur)\n            }, true)\n            break;\n        case 'components':\n            res = value.reduce((acc, cur) => {\n                return acc && isComponent(cur)\n            }, true)\n            break;\n        case 'mixed' :\n            res = true;\n            break;\n        case 'any':\n            res = true;\n            break;\n        default:\n            throw new ValidationError(`Type ${type} not supported in Array`);\n    }\n    return res;\n}\n\nexport const isMap = (value, type) => {\n    if (! (value instanceof Map)) {\n        return false\n    }\n\n    let values = Array.from(value.values())\n\n    return isArray(values, type)\n\n}\n\nexport const isSet = (value, type) => {\n    if (! (value instanceof Set)) {\n        return false\n    }\n\n    let values = Array.from(value.values())\n\n    return isArray(values, type)\n}\n\nexport const isComponent = (value) => {\n    if (!value.hasOwnProperty('name')) {\n        return false;\n    }\n\n    // data is optional because we can have flag components\n    // but if we have data, it must have the correct structure\n    if (value.hasOwnProperty('data')) {\n        //check if data is an object and make sure all entries have a type property defined.\n        const data = Object.entries(value.data);\n        //if value.data is not iterable, then it returns an empty array\n        if (data.length == 0) {\n            return false\n        }\n        //check that the actual values of data are correct.\n        return data.reduce((acc, cur) => {\n            return acc\n                && cur.length > 1\n                && isString(cur[0]) // property key must be a string\n                && cur[1].hasOwnProperty('type') // value of each data must contain a `type` property\n                && isEnum(cur[1]['type'], ['string', 'number', 'any', 'mixed']) // check if `type` is supported\n        }, true)\n        \n    }\n\n    return true;\n\n\n}","module.exports = require(\"crypto\");"],"sourceRoot":""}