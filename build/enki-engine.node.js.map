{"version":3,"sources":["webpack://EnkiEngine/webpack/universalModuleDefinition","webpack://EnkiEngine/webpack/bootstrap","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/bytesToUuid.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/index.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/md5.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/rng.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/sha1.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v1.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v3.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v35.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v4.js","webpack://EnkiEngine/./node_modules/uuid/dist/esm-node/v5.js","webpack://EnkiEngine/./src/componentManager.js","webpack://EnkiEngine/./src/entityManager.js","webpack://EnkiEngine/./src/index.js","webpack://EnkiEngine/./src/storage/index.js","webpack://EnkiEngine/./src/storage/memoryStorage.js","webpack://EnkiEngine/./src/systemManager.js","webpack://EnkiEngine/./src/utils/validate.js","webpack://EnkiEngine/external \"crypto\""],"names":[],"mappings":"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;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4CAAQ;AACnB,gBAAgB,EAAE,MAAM,kBAAkB,yBAAyB,qBAAqB;AACxF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,EAAE,mCAAmC,YAAY;AACjE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,wBAAwB,cAAc,sBAAsB,SAAS;AACrE;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpHA;AAAA;AAAA;AAAkC;;AAE3B;AACP;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,mBAAmB,+CAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,EAAE;AACf,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACM;AACN;AACN;;AAE7C;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,IAAI;AACf,cAAc,gBAAgB,2CAA2C,qBAAqB,oEAAoE,kBAAkB;AACpL;AACA;AACA,iBAAiB,oFAAoF,KAAK;;AAE1G;AACA,+CAA+C,YAAY;;AAE3D;AACA;AACA;AACA;AACA,GAAG;AACH,cAAc,yDAAO;AACrB;;AAEA,oBAAoB,uEAAa;;AAEjC,uBAAuB,6EAAgB;;AAEvC,oBAAoB,uEAAa;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;;AC1CtB;AAAA;AAAA;AAAgD;;AAEzC;AACP,EAAE,2EAAa;AACf;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;AACA,cAAc;AACd;AACA;AACO;AACP;AACA,+BAA+B;AAC/B,mCAAmC;AACnC,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,6BAA6B,SAAS;AACtC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB,IAAI;AACrB;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA,8BAA8B,cAAc,aAAa,SAAS;AAClE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA,iCAAiC,cAAc,aAAa,SAAS;AACrE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5IA;AAAA;AAAA;AAAyC;;AAElC;;AAEP;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,+DAAO;AACf,qBAAqB,YAAY;AACjC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,eAAe,IAAI,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;ACtEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,8BAA8B;AAC9B,2BAA2B;AAC3B;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;;;;;;;;;;;;ACjDA,mC","file":"enki-engine.node.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EnkiEngine\"] = factory();\n\telse\n\t\troot[\"EnkiEngine\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction bytesToUuid(buf, offset_) {\n  const offset = offset_ || 0; // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n\n  return (byteToHex[buf[offset + 0]] + byteToHex[buf[offset + 1]] + byteToHex[buf[offset + 2]] + byteToHex[buf[offset + 3]] + '-' + byteToHex[buf[offset + 4]] + byteToHex[buf[offset + 5]] + '-' + byteToHex[buf[offset + 6]] + byteToHex[buf[offset + 7]] + '-' + byteToHex[buf[offset + 8]] + byteToHex[buf[offset + 9]] + '-' + byteToHex[buf[offset + 10]] + byteToHex[buf[offset + 11]] + byteToHex[buf[offset + 12]] + byteToHex[buf[offset + 13]] + byteToHex[buf[offset + 14]] + byteToHex[buf[offset + 15]]).toLowerCase();\n}\n\nexport default bytesToUuid;","export { default as v1 } from './v1.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';","import crypto from 'crypto';\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('md5').update(bytes).digest();\n}\n\nexport default md5;","import crypto from 'crypto';\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  return crypto.randomFillSync(rnds8);\n}","import crypto from 'crypto';\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto.createHash('sha1').update(bytes).digest();\n}\n\nexport default sha1;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js'; // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || bytesToUuid(b);\n}\n\nexport default v1;","import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;","import bytesToUuid from './bytesToUuid.js';\n\nfunction uuidToBytes(uuid) {\n  // Note: We assume we're being passed a valid uuid string\n  const bytes = [];\n  uuid.replace(/[a-fA-F0-9]{2}/g, function (hex) {\n    bytes.push(parseInt(hex, 16));\n  });\n  return bytes;\n}\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function (name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = uuidToBytes(namespace);\n    }\n\n    if (!Array.isArray(value)) {\n      throw TypeError('value must be an array of bytes');\n    }\n\n    if (!Array.isArray(namespace) || namespace.length !== 16) {\n      throw TypeError('namespace must be uuid string or an Array of 16 byte values');\n    } // Per 4.3\n\n\n    const bytes = hashfunc(namespace.concat(value));\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return bytesToUuid(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return bytesToUuid(rnds);\n}\n\nexport default v4;","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import * as Validate from './utils/validate';\n\nexport const ComponentManager = (storage, verbose) => {\n\n  const _storage = storage;\n  const _registeredComponents = new Map();\n\n  const _log = (...$msg) => {\n    if (verbose) {\n      console.log('Component Manager: ', ...$msg);\n    }\n  };\n\n  const _validate = (ComponentId, componentValue) => {\n    //check if component is registered\n    const c = _registeredComponents.get(ComponentId);\n    if (typeof c === 'undefined') {\n      return false;\n    }\n\n    //check if values are correct\n    for (let [k, v] of Object.entries(c)) {\n      const validateFunctionName = 'is' + v['type'].charAt(0).toUpperCase() + v['type'].slice(1);\n      //if value is not passed and we have a default or value is optional then we are good\n      if (typeof componentValue[k] === 'undefined' && (\n        (typeof (v.optional) !== 'undefined' && v.optional === true) ||\n        typeof (v.default) !== 'undefined')\n      ) {\n        continue;\n      }\n      // 'any' type of data is not validated.\n      if(v.type == 'any'){\n        continue;\n      }\n      //we have a value so we test\n      let args = [];\n      if(v.type == 'enum') {\n        args.push(v.allowed);\n      }\n      if(v.type == 'array'){\n        args.push(v.childType);\n      }\n      if (!Validate[validateFunctionName](componentValue[k],...args)) {\n        _log(`${k} => ${componentValue[k]} failed the validation ${validateFunctionName}`);\n        return false;\n      }\n    }\n\n    //check if extra non existent property were passed to component\n    const defaultSchema = Object.keys(c);\n    for (const k of Object.keys(componentValue)) {\n      if (!defaultSchema.includes(k)) {\n        _log(`${k} is not a valid property for the ${ComponentId} Component.`);\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Add a Component to an existing entity\n   * @param {any} entityId - Entity Id\n   * @param {string} ComponentId - Component type to add\n   * @param {object} value - Object following the data structure of component to pass initial values to component\n   * @returns {boolean} True if succesfull else false\n   */\n  const add = (entityId, ComponentName, value = {}) => {\n    if (_validate(ComponentName, value)) {\n      const c = _registeredComponents.get(ComponentName);\n      const defaultValues = Object.fromEntries(Object.entries(c).map(([k, v]) => {\n        return [k, v.default];\n      }));\n      _storage.addEntityComponent(entityId, ComponentName, Object.assign(defaultValues, value));\n      return true;\n    } else {\n      _log(`Component ${ComponentName} could not added to ${entityId} due to fail validation`);\n      return false;\n    }\n  };\n\n  /**\n   * Remove a component from an existing Entity\n   * @param {any} entityId - Entity Id\n   * @param {string} ComponentName - Component to remove\n   * @returns {boolean} - True if successfull else false\n   */\n  const remove = (entityId, ComponentName) => {\n    return _storage.removeEntityComponent(entityId, ComponentName);\n  };\n\n  /**\n   * Register a new component type\n   * @param {object} componentSchema\n   * @returns {boolean} - True if successfull, else false\n   */\n  const register = (componentSchema) => {\n    if(!componentSchema.hasOwnProperty('name')) {\n      return false;\n    }\n    _log(`Registering ${componentSchema.name} Component`)\n    const data = componentSchema.data || {};\n    _registeredComponents.set(componentSchema.name, data);\n    return true;\n  };\n\n  const list = () => {\n    return new Map(_registeredComponents)\n  }\n\n  return {\n    add,\n    remove,\n    register,\n    list\n  };\n};\n","import {v4 as uuidv4} from 'uuid';\n\nexport const EntityManager = (storage) => {\n  const _storage = storage;\n\n  /**\n   * Add a new entity\n   * @returns {string} - Entity Id\n   */\n  const add = () => {\n    const entity = uuidv4();\n    _storage.addEntity(entity);\n    return entity;\n  };\n\n  /**\n   * Remove an entity\n   * @param {*} entity - Entity Id to remove\n   * @returns {boolean} - True if successful, else false\n   */\n  const remove = (entity) => {\n    return _storage.removeEntity(entity);\n  };\n\n  /**\n   * Retrieve an entity\n   * @param {*} id - Entity Id\n   * @returns {*} - Entity Id if it exists. Undefined if it does not exists\n   */\n  const get = (id) => {\n    _storage.getEntity(id);\n    return id;\n  };\n\n  /**\n   * Retrieve all entities stored\n   * @returns {Iterator} - Iterator that list all entities\n   */\n  const list = () => {\n    return _storage.getEntities().values();\n  };\n\n  return {\n    add,\n    get,\n    list,\n    remove,\n  };\n};\n","import { EntityManager } from './entityManager.js';\nimport { ComponentManager } from './componentManager.js';\nimport { SystemManager } from './systemManager.js';\nimport { Storage } from './storage/index.js';\n\n/**\n * Create an Enki Engine instance\n * @param {string} storageType - The type of storage to use, either 'MemoryStorage' or 'custom'\n * @param {string} mode - debug or production.\n * @param {func} storageInstance - a Storage instance, only used if storageType is set to 'custom'\n * @param {any} rest - unused at the moment\n * @returns {{EntityManager: {add: (function(*): string), remove: remove}, ComponentManager: {add: add, remove: (function(*=, *=): boolean|*), register: register}, SystemManager: {execute: execute, register: register}}}\n * @constructor\n */\nconst Engine = ({storageType = 'MemoryStorage', mode = 'production', storageInstance = null, ...rest} = {}) => {\n\n  //get storage\n  console.log(`Starting Enki ECS Engine with ${storageType}`)\n\n  const verbose = mode == 'debug' ? true : false;\n  let storage = null;\n  if(storageType == 'custom') {\n    storage = storageInstance(verbose);\n  } else {\n    storage = Storage[storageType](verbose);\n  }\n\n  const entityMgr = EntityManager(storage, verbose);\n\n  const componentMgr = ComponentManager(storage, verbose);\n\n  const systemMgr = SystemManager(storage, verbose);\n\n  return {\n    EntityManager: entityMgr,\n    SystemManager: systemMgr,\n    ComponentManager: componentMgr,\n    Storage: storage\n  }\n\n}\n\nexport default Engine;\n","import { MemoryStorage } from './memoryStorage';\n\nexport const Storage =  {\n  MemoryStorage\n}\n","/**\n *\n * @param verbose\n * @returns {{addEntity: (function(*): Set<any>), removeEntityComponent: removeEntityComponent, getEntityComponents: (function(*): any), getEntities: (function(): Set<*>), addEntityComponent: addEntityComponent, getEntity: (function(*=): *), removeEntity: (function(*=): boolean), getEntityByComponents: (function(Array): *)}}\n * @constructor\n */\nexport const MemoryStorage = (verbose) => {\n    const _verbose = verbose;\n    const Entities = new Set(); //list of entities created\n    const ComponentMap = new Map(); //a map for quickly retrieve entity that have a given component (ComponentId => [entity1, entity2...])\n    const EntityComponents = new Map(); // a 3D map with primary key being entity ID with a map of all components\n\n    const _log = (...$msg) => {\n        if (verbose) {\n            console.log('Memory Store: ', ...$msg)\n        }\n    }\n\n    /**\n     * Add an Entity to storage\n     * @param {any} entityId - Any value that is unique\n     * @returns {Set<any>}\n     */\n    const addEntity = (entityId) => {\n        EntityComponents.set(entityId, new Map())\n        _log(`Saving Entity ${entityId}`)\n        return Entities.add(entityId)\n    }\n\n    /**\n     * Remove an entity from storage\n     * @param entityId\n     * @returns {boolean}\n     */\n    const removeEntity = (entityId) => {\n        _log(`Removing Entity ${entityId}`)\n        return Entities.delete(entityId)\n    }\n\n    /**\n     * Return EntityId or undefined if the entity does not exists\n     * @param entityId\n     * @returns {entityId}\n     */\n    const getEntity = (entityId) => {\n        _log(`Get Entity ${entityId}`)\n        const e = Entities.has(entityId) ? entityId : undefined;\n        _log(`Found Entity ${entityId}`)\n        return e\n    }\n\n    /**\n     * Return a Set containing all entities\n     * @returns {Set<any>}\n     */\n    const getEntities = () => {\n        //returning a new set so users can not override the Entities Set by inadvertence\n        return new Set(Entities);\n    }\n\n    /**\n     * Get all components attached to an entity\n     * @param {any} entityId - EntityId to retrieve components from\n     * @returns {Set} - Set of components\n     */\n    const getEntityComponents = (entityId) => {\n        _log(`Get Entity Components for ${entityId}`)\n        return EntityComponents.has(entityId) ? EntityComponents.get(entityId) : new Set();\n    }\n\n    /**\n     * List all entities that have the component attached\n     * @param {array} components - array of components name\n     * @returns {Set} - List of entities\n     */\n    const getEntityByComponents = (components) => {\n        _log(`Get List of Entities by Components for `, components)\n        if (!Array.isArray(components)) {\n            throw Error('Components must be an array');\n        }\n        const e = components.reduce((acc, val) => {\n            if (acc.size == 0) {\n                return ComponentMap.get(val) || new Set();\n            }\n\n            return new Set([...acc].filter(i => {\n                const c = ComponentMap.get(val)\n                if(typeof c === 'undefined') {\n                    return false\n                }\n                return c.has(i)\n            }))\n        }, new Set());\n        _log(`Found Entities`, e)\n        return e;\n    }\n\n    /**\n     * Add a component to an entity\n     * @param {any} entityId - EntityId\n     * @param {string} componentName - Name of Component to add to entity\n     * @param {object} component - Component value for initialisation\n     */\n    const addEntityComponent = (entityId, componentName, component) => {\n        _log(`Add Component ${componentName} to Entity ${entityId}`)\n        if (!ComponentMap.has(componentName)) {\n            ComponentMap.set(componentName, new Set([entityId]));\n            EntityComponents.get(entityId).set(componentName, component);\n        } else {\n            ComponentMap.get(componentName).add(entityId);\n            EntityComponents.get(entityId).set(componentName, component);\n        }\n    }\n\n    /**\n     * Remove Component from an entity\n     * @param {any }entityId - EntityId to remove component from\n     * @param {string} componentName - Component Name\n     * @returns {boolean} - True if successfull\n     */\n    const removeEntityComponent = (entityId, componentName) => {\n        _log(`Remove Component ${componentName} to Entity ${entityId}`)\n        if (!ComponentMap.has(componentName)) {\n            return false;\n        } else {\n            return EntityComponents.get(entityId).delete(componentName) &&\n                ComponentMap.get(componentName).delete(entityId);\n        }\n    }\n\n    return {\n        addEntity,\n        removeEntity,\n        getEntity,\n        getEntities,\n        addEntityComponent,\n        removeEntityComponent,\n        getEntityByComponents,\n        getEntityComponents\n    }\n}\n","import {isArray} from './utils/validate';\n\nexport const SystemManager = (storage, verbose) => {\n\n  const _storage = storage;\n  const _registeredSystems = new Map();\n\n\n  const _log = ( ...$msg) => {\n    if(verbose) {\n      console.log('System Manager: ',...$msg)\n    }\n  }\n\n  const _query = (q) => {\n    return _storage.getEntityByComponents(q);\n  }\n\n  const _validate = (system) => {\n    //check that system is a function with the correct prototype\n    if(!typeof(system) === 'function' || !system.hasOwnProperty('query')) {\n      _log('Trying to register a system that is either not a function or does not have a name and query defined');\n      return false;\n    }\n\n    if(!isArray(system.query, 'string')){\n      _log(`System ${system.name} does not have a correct query. A query must be an array of string.`)\n      return false;\n    }\n\n    return true\n  }\n\n\n  /**\n   * Execute all registered systems\n   * @returns {Map{Array}} - Return values from each system\n   */\n  const execute = () => {\n    // loop through all systems\n    const returnValues = new Map();\n    for(let [name, system] of _registeredSystems){\n      const entities = _query(system.query);\n      returnValues.set(name,new Map())\n      entities.forEach((e) => {\n        returnValues.get(name).set(e, system(_storage.getEntityComponents(e)))\n      })\n    }\n    return returnValues;\n  }\n\n  /**\n   * Register a new system\n   * @param {function} system - A system to be registered\n   * @returns {boolean} - True if successful else false\n   */\n  const register = (system) => {\n    if(_validate(system)){\n      _log(`Registering ${system.name} System`)\n      _registeredSystems.set(system.name, system);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return {\n    execute,\n    register\n  }\n\n}\n","\nexport const isNumber = (value) => {\n  return !isNaN(value)\n}\n\nexport const isAny = (value) => {\n  if(typeof(value) !== 'undefined'){\n    return true;\n  }\n  return false;\n}\n\nexport const isString = (value) => {\n  if (typeof value === 'string' || value instanceof String) {\n    return true;\n  }\n  return false;\n}\n\nexport const isEnum = (value, allowed) => {\n  return allowed.includes(value)\n}\n\nexport const isArray = (value, type) => {\n  //check if array\n  const isArray = Array.isArray(value);\n  if(!isArray)  {\n    return false\n  }\n  //check type\n\n  let res = false;\n  switch (type) {\n    case 'string':\n      res = value.reduce((acc,cur) => {\n        return acc && isString(cur)\n      }, true)\n      break;\n    case 'number':\n      res = value.reduce((acc,cur) => {\n        return acc && isNumber(cur)\n      }, true)\n      break;\n    case 'mixed' : res = true; break;\n    case 'any': res = true; break;\n    default:\n      throw new TypeError(`Type ${type} not supported in Array`);\n  }\n  return res;\n}\n","module.exports = require(\"crypto\");"],"sourceRoot":""}